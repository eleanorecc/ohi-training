---
title: "Tidyr & Dplyr Training"
author: "Ellie Campbell"
date: "3/6/2018"
output: html_document
---


### Data Wrangling with dplyr


Data scientist spend too much time, about 50-80% of time doing collection and prep of data before useful exploration! 

Using tidyverse in R --> manipulating columns and rows

Wrangling is part of the "transform" or "tidy" phase of data analysis workflow

What is the difference between tidying and transforming?

### What is tidy data?

* Each variable in its own column
* Each observation saved in its own row

### The Tidyverse

A suite of R packages for data wrangling



***

# Gapminder Wrangle

We're going to wrangle gapminder data using `dplyr`.

```{r}
library(tidyverse) # install.packages('tidyverse') if get error saying package not found when this is run
```

When run "library(tidyverse)" get warning messages about functions masked by tidyverse

Will be using gapminder data from OHI-Science/data-science-training
Want raw csv data, can click "raw" tab and copy URL (https://raw.githubusercontent.com/OHI-Science/data-science-training/master/data/gapminder.csv)


```{r}
# read in dataset from url:

gapminder <- read_csv('https://raw.githubusercontent.com/OHI-Science/data-science-training/master/data/gapminder.csv')

# returns message about how data is parsed, i.e. was each column read as a string or as an integer, or as a double
```


## Explore Dataframe as a Whole:
```{r}
head(gapminder) # shows first 6 rows by default, but can specify more rows by including an additional parameter
tail(gapminder, 15)

str(gapminder) # structure of gapminder, gives information about dataframe; helpful to see what class each variable is so can determine whether can use different types of functions
names(gapminder) # tells us the column (variable) names

dim(gapminder) # tells the dimensions of the dataframe: number rows by number of columns
nrow(gapminder) # number of rows
ncol(gapminder) # number of columns

```


Most functions adn packages will expect your data to be in a dataframe; usually by default, data is read into a dataframe

Dataframes are awesome because they can contain both characters and numbers

Tibbles and tibble dataframes (`tbl` or `tbl_df`) are dataframes which can also contain other dataframes or things like ggplot

The function `c()` combines things into a list or a vector -- "combine" function

Tidyverse tries to keep everything consistent; if one class goes in, returns an object of the same class


## Summary Statistics for Dataframe:
```{r}
summary(gapminder) # for numeric values will return min median mean max and quartiles; for character vars will tell you it is a character class an the length

library(skimr) # run install.package('skimr') if have error 'package not found'
skim(gapminder) # cool package to look at data 'at a glance' and plays nicely with other tidyverse packages


```

## Explore Inside the Dataframe

```{r}
# gapminder$lifeExp gives information just for the single column in the dataframe, called "lifeExp" -- returns the entire column...
head(gapminder$lifeExp) # output is shown in integer vector
str(gapminder$lifeExp) # not esspecially enlightening looking at structure of just one column...
```


## Dplyr Basics:

* `filter()` subsets data by rows
* `select()` selects columns (i.e. variables)
* `mutate()` adds a variable based on other columns
* `summarize()` collapses many columns' values into a single new columnn

Will always return a dataframe

Work similarly, programatically

Can be strung together

```{r}

# Filter:

filter(gapminder, lifeExp <29) # want to filter to look at where life expectancy is less than 29 years old; filter based on condition specified in second arguement of the function
filter(gapminder, country == "Mexico")
filter(gapminder, country %in% c("Mexico", "Chile"))
filter(gapminder, country == "Mexico" | country == "Chile") # does the same thing as above

# Select:

select(gapminder, year, lifeExp) # select just the year and life expectancy columns
select(gapminder, -continent, -lifeExp) # can use minus to deselect certain columns

# Combining Select and Filter

gap_cambodia <- filter(gapminder, country == "Cambodia") # filter the country from Cambodia 
gap_cambodia_2 <- select(gap_cambodia, -continent, -lifeExp) # and remove continent and life expectancy columns..
gap_cambodia_2 # view results

```

## Pipe Operator!

**Life-changing** pipe operator: %>%, the keyboard shortcut is shift-command-n

Essentially like saying "and then"

This allows you to string together a bunch of functions, and have fewer intermediate variables

Tell it up front what data you will be using; that is carried throughout the next specified operations strung together with pipe operators

```{r}
gapminder %>% head() # equivalent to head(gapminder)
gapminder %>% head(3) # take gapminder data, and then return the first three rows; no longer need to specify the datam, because that is announced up front

gap_cambodia <- gapminder %>% filter(country == "Cambodia") %>% select(-continent, -lifeExp) # this is same as what we did above, but is cleaner since data is announced upfront and then operations are chained
gap_cambodia
```

## More Tidyverse Verbs

Add variables uing `mutate`:
```{r}
gapminder %>% 
  mutate(index = 1:nrow(gapminder)) # mutate takes dataframe and adds another column to it; index is name of new column and 1:nrow(gapminder) tells it to make rowvalues the vector 1 though the number of rows

gapminder %>% 
  mutate(gdp = pop * gdpPercap) # since already specified using gapminder dataset, don't have to use the $ notation to get individual dataframe column; also Rstudio will recognize now+ try to autofill colnames

```

Find the maximum gdpPercap of Egypt and Vietname, and save it in a new colunm:
```{r}
gapminder %>%
  filter(country %in% c("Egypt", "Vietnam")) %>% 
  mutate(max_gdp = max(gdpPercap)) # calculates the maximum of both Egypt and Vietnam TOGETHER...
  
```

To make max_gdp for each Egype and Vietnam (within each country respectively)...

### `group_by()`

```{r}
x <- gapminder %>%
  filter(country %in% c("Egypt", "Vietnam")) %>% # could put group_by before this filter statement, but then would force R to do more work, grouping more variables (more computationally intensive)
  group_by(country) %>%  # as long as group_by before mutating, will do mutate calculations on specified groups
  mutate(max_gdp = max(gdpPercap)) %>% # ALWAYS END A GROUP_BY WITH UNGROUP, OTHER WISE WILL CONSIDER CLUSTERS IN LATER STEPS
  ungroup()

str(x)
```


### `summarize()`

Helpful to use with `group_by`

```{r}
gapminder %>% 
  group_by(country) %>% 
  mutate(gdp = pop*gdpPercap) %>% 
  summarize(max_gdp = max(gdp)) %>% 
  ungroup() %>% 
  arrange(max_gdp) # rearranged order of rows, defaults to assending order (minimum to maximum) based on maximum gdp; can make into descending order by including "desc()" e.g. "arrange(desc(max_gdp)))"
```


Let's now find the maximum life expectancy for countries in Asia, hint: max()

```{r}
gapminder %>%
  filter(continent == "Asia") %>% 
  group_by(country) %>% 
  summarize(max_lifeExp = max(lifeExp)) %>% 
  ungroup()
```


# Joining Datasets

Combining datasets into one dataframe so can streamline analysis: Relational data/Joining data

Might be different ways in which you want to combine data

* Non-matching colunms (like arcgis join)
* Non-matching observations (like arcgis merge)

Ask yourself: what do you want to keep?

If want to merge additional observations with some differences in included variables, may end up with NAs

* Left-Join: join matching rows from B to A, keeping all observations from table A
* Right-Join: joing mtatching rows from A to B, keeping all observations from table B
* Inner-Join: Retain only rows in both sets; might result in some lost data
* Full-Join: Retain all values, all rows; can later filter out all rows with NAs in second step after viewing NAs


```{r}
co2 <- read_csv('https://raw.githubusercontent.com/OHI-Science/data-science-training/master/data/co2.csv') # read in CO2 data
co2 %>% head() # shows in rmd the first 6 rows of the co2 data

gap_2007 <- gapminder %>% 
  filter(year == 2007)

lj <- left_join(gap_2007, co2, by = "country") # join the co2 data to the gap2007 subset by the country variable, i.e. match by looking at the country names
lj %>% summary() # can see from the summary that there are 135 NAs out of 142 observations in the left join dataframe


rj <- right_join(gap_2007, co2, by = "country")
head(rj)


```










## Other random notes from training session...

Shortcut: control-alt-m opens commit window for github

If forget pipe operator and don't see right away can reindent lines ("Code" > "Reindent Lines"), shortcut: command I

Command-arrow to jump to the end of the code line


